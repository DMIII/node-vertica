// Generated by CoffeeScript 2.4.1
var Authentication, BackendMessage, Connection, EventEmitter, FrontendMessage, Query, errors, net, util;

util = require('util');

net = require('net');

EventEmitter = require('events').EventEmitter;

FrontendMessage = require('./frontend_message');

BackendMessage = require('./backend_message');

Authentication = require('./authentication');

Query = require('./query');

errors = require('./errors');

Connection = class Connection extends EventEmitter {
  constructor(connectionOptions) {
    var base, base1, base2, base3;
    super();
    this.connectionOptions = connectionOptions;
    if ((base = this.connectionOptions).host == null) {
      base.host = 'localhost';
    }
    if ((base1 = this.connectionOptions).port == null) {
      base1.port = 5433;
    }
    if ((base2 = this.connectionOptions).ssl == null) {
      base2.ssl = 'optional';
    }
    if ((base3 = this.connectionOptions).keepAlive == null) {
      base3.keepAlive = false;
    }
    this.connected = false;
    this.busy = true;
    this.queue = [];
    this.parameters = {};
    this.key = null;
    this.pid = null;
    this.transactionStatus = null;
    this.incomingData = new Buffer(0);
  }

  connect(callback) {
    var initialErrorHandler;
    this.connectedCallback = callback;
    this.connection = net.createConnection(this.connectionOptions.port, this.connectionOptions.host);
    initialErrorHandler = (err) => {
      if (this.connectedCallback) {
        return this.connectedCallback(err.message);
      } else {
        return this.emit('error', err);
      }
    };
    this.connection.on('error', initialErrorHandler);
    return this.connection.on('connect', () => {
      this.connection.removeListener('error', initialErrorHandler);
      this.connected = true;
      this._bindEventListeners();
      if (this.connectionOptions.keepAlive) {
        this.connection.setKeepAlive(true);
      }
      if (this.connectionOptions.ssl) {
        this._writeMessage(new FrontendMessage.SSLRequest);
        return this.connection.once('data', (buffer) => {
          var conn, err, sslOptions;
          if ('S' === buffer.toString('utf-8')) {
            sslOptions = {
              key: this.connectionOptions.sslKey,
              cert: this.connectionOptions.sslCert,
              ca: this.connectionOptions.sslCA
            };
            return conn = require('./starttls')(this.connection, sslOptions, () => {
              var err;
              if (!conn.authorized && this.connectionOptions.ssl === 'verified') {
                conn.end();
                this.disconnect();
                err = new errors.SSLError(conn.authorizationError);
                if (this.connectedCallback) {
                  return this.connectedCallback(err);
                } else {
                  return this.emit('error', err);
                }
              } else {
                if (!conn.authorized) {
                  this.emit('warn', conn.authorizationError);
                }
                this.connection = conn;
                this._bindEventListeners();
                return this._handshake();
              }
            });
          } else if (this.connectionOptions.ssl === "optional") {
            return this._handshake();
          } else {
            err = new errors.SSLError("The server does not support SSL connection");
            if (this.connectedCallback) {
              return this.connectedCallback(err);
            } else {
              return this.emit('error', err);
            }
          }
        });
      } else {
        return this._handshake();
      }
    });
  }

  _bindEventListeners() {
    this.connection.once('close', this._onClose.bind(this));
    this.connection.once('error', this._onError.bind(this));
    return this.connection.once('timeout', this._onTimeout.bind(this));
  }

  disconnect(error) {
    if (error) {
      this._onError(error);
    }
    if (this.connection.connected) {
      this._writeMessage(new FrontendMessage.Terminate());
    }
    return this.connection.end();
  }

  isSSL() {
    return (this.connection.pair != null) && (this.connection.encrypted != null);
  }

  _scheduleJob(job) {
    if (this.busy) {
      this.queue.push(job);
      this.emit('queuejob', job);
    } else {
      this._runJob(job);
    }
    return job;
  }

  _runJob(job) {
    if (!this.connected) {
      throw new errors.ClientStateError("Connection is closed");
    }
    if (this.busy) {
      throw new errors.ClientStateError("Connection is busy");
    }
    this.busy = true;
    this.currentJob = job;
    job.run();
    return job;
  }

  _processJobQueue() {
    if (this.queue.length > 0) {
      return this._runJob(this.queue.shift());
    } else {
      return this.emit('ready', this);
    }
  }

  query(sql, callback) {
    return this._scheduleJob(new Query(this, sql, callback));
  }

  _queryDirect(sql, callback) {
    return this._runJob(new Query(this, sql, callback));
  }

  copy(sql, source, callback) {
    var q;
    q = new Query(this, sql, callback);
    q.copyInSource = source;
    return this._scheduleJob(q);
  }

  _handshake() {
    var authenticationFailureHandler, authenticationHandler;
    authenticationFailureHandler = (err) => {
      err = new errors.AuthenticationError(err);
      if (this.connectedCallback) {
        return this.connectedCallback(err);
      } else {
        return this.emit('error', err);
      }
    };
    authenticationHandler = (msg) => {
      switch (msg.method) {
        case Authentication.methods.OK:
          return this.once('ReadyForQuery', (msg) => {
            this.removeListener('ErrorResponse', authenticationFailureHandler);
            return this._initializeConnection();
          });
        case Authentication.methods.CLEARTEXT_PASSWORD:
        case Authentication.methods.MD5_PASSWORD:
          this._writeMessage(new FrontendMessage.Password(this.connectionOptions.password, msg.method, {
            salt: msg.salt,
            user: this.connectionOptions.user
          }));
          return this.once('Authentication', authenticationHandler);
        default:
          throw new errors.ClientStateError(`Authentication method ${msg.method} not supported.`);
      }
    };
    this.connection.on('data', this._onData.bind(this));
    this._writeMessage(new FrontendMessage.Startup(this.connectionOptions.user, this.connectionOptions.database));
    this.once('ErrorResponse', authenticationFailureHandler);
    this.once('Authentication', authenticationHandler);
    this.on('ParameterStatus', (msg) => {
      return this.parameters[msg.name] = msg.value;
    });
    this.on('BackendKeyData', (msg) => {
      return [this.pid, this.key] = [msg.pid, msg.key];
    });
    return this.on('ReadyForQuery', (msg) => {
      this.busy = false;
      this.currentJob = false;
      return this.transactionStatus = msg.transactionStatus;
    });
  }

  _initializeConnection() {
    var chain, i, initializer, initializers, len;
    initializers = [];
    if (!this.connectionOptions.skipInitialization) {
      if (this.connectionOptions.interruptible) {
        initializers.push(this._initializeInterrupt);
      }
      if (this.connectionOptions.role != null) {
        initializers.push(this._initializeRoles);
      }
      if (this.connectionOptions.searchPath != null) {
        initializers.push(this._initializeSearchPath);
      }
      if (this.connectionOptions.timezone != null) {
        initializers.push(this._initializeTimezone);
      }
      if (this.connectionOptions.initializer != null) {
        initializers.push(this.connectionOptions.initializer);
      }
    }
    chain = this._initializationSuccess.bind(this);
    for (i = 0, len = initializers.length; i < len; i++) {
      initializer = initializers[i];
      chain = initializer.bind(this, chain, this._initializationFailure.bind(this));
    }
    return chain();
  }

  _initializeRoles(next, fail) {
    var roles;
    roles = this.connectionOptions.role instanceof Array ? this.connectionOptions.role : [this.connectionOptions.role];
    return this._queryDirect(`SET ROLE ${roles.join(', ')}`, (err, result) => {
      if (err != null) {
        return fail(err);
      } else {
        return next();
      }
    });
  }

  _initializeSearchPath(next, fail) {
    var searchPath;
    searchPath = this.connectionOptions.searchPath instanceof Array ? this.connectionOptions.searchPath : [this.connectionOptions.searchPath];
    return this._queryDirect(`SET SEARCH_PATH TO ${searchPath.join(', ')}`, (err, result) => {
      if (err != null) {
        return fail(err);
      } else {
        return next();
      }
    });
  }

  _initializeTimezone(next, fail) {
    return this._queryDirect(`SET TIMEZONE TO '${this.connectionOptions.timezone}'`, (err, result) => {
      if (err != null) {
        return fail(err);
      } else {
        return next();
      }
    });
  }

  _initializeInterrupt(next, fail) {
    return this._queryDirect("SELECT session_id FROM v_monitor.current_session", (err, result) => {
      if (err != null) {
        fail(err);
      }
      this.sessionID = result.theValue();
      return next();
    });
  }

  _initializationSuccess() {
    this.on('ReadyForQuery', this._processJobQueue.bind(this));
    this._processJobQueue();
    if (this.connectedCallback) {
      return this.connectedCallback(null, this);
    }
  }

  _initializationFailure(err) {
    if (this.connectedCallback) {
      return this.connectedCallback(err);
    } else {
      return this.emit('error', err);
    }
  }

  _onData(buffer) {
    var bufferedData, message, size;
    // Append the new data with the previous buffer's residue if there was any.
    if (this.incomingData.length === 0) {
      this.incomingData = buffer;
    } else {
      bufferedData = new Buffer(this.incomingData.length + buffer.length);
      this.incomingData.copy(bufferedData);
      buffer.copy(bufferedData, this.incomingData.length);
      this.incomingData = bufferedData;
    }
    // start at 1 to skip the message ID
    while (this.incomingData.length >= 5) {
      size = this.incomingData.readUInt32BE(1);
      if (size + 1 <= this.incomingData.length) {
        // parse message
        message = BackendMessage.fromBuffer(this.incomingData.slice(0, size + 1));
        if (this.debug) {
          console.log('<=', message.event, message);
        }
        this.emit('message', message);
        this.emit(message.event, message);
        // update loop variables
        this.incomingData = this.incomingData.slice(size + 1);
      } else {
        // message fragmented, keep collecting
        break;
      }
    }
    // explicit return to avoid coffeescript generating result array
    return void 0;
  }

  _onClose() {
    var error;
    this.connected = false;
    error = new errors.ConnectionError("The connection was closed.");
    if (this.currentJob) {
      this.currentJob.onConnectionError(error);
    }
    this.currentJob = false;
    return this.emit('close');
  }

  _onTimeout() {
    var error;
    error = new errors.ConnectionError("The connection timed out.");
    if (this.currentJob) {
      this.currentJob.onConnectionError(error);
    }
    this.currentJob = false;
    return this.emit('timeout');
  }

  _onError(err) {
    var error, ref;
    error = new errors.ConnectionError((ref = err.message) != null ? ref : err.toString());
    if (this.currentJob) {
      this.currentJob.onConnectionError(error);
    }
    this.currentJob = false;
    return this.emit('error', error);
  }

  _writeMessage(msg, callback) {
    if (this.debug) {
      console.log('=>', msg.__proto__.constructor.name, msg);
    }
    return this.connection.write(msg.toBuffer(), callback);
  }

  isInterruptible() {
    return this.sessionID != null;
  }

  _interruptConnection(cb) {
    var bareClient, bareConnectionOptions;
    if (this.sessionID != null) {
      bareConnectionOptions = {
        skipInitialization: true
      };
      bareConnectionOptions.__proto__ = this.connectionOptions;
      bareClient = new Connection(bareConnectionOptions);
      return bareClient.connect(cb);
    } else {
      return cb(new errors.ClientStateError("Cannot interrupt connection! It's not initialized as interruptible."), null);
    }
  }

  _success(err, cb) {
    if (err != null) {
      if (cb != null) {
        cb(err);
      } else {
        this.emit('error', err);
      }
      return false;
    } else {
      return true;
    }
  }

  interruptSession(cb) {
    return this._interruptConnection((err, conn) => {
      if (this._success(err, cb)) {
        return conn.query(`SELECT CLOSE_SESSION('${this.sessionID}')`, (err, rs) => {
          conn.disconnect();
          if (this._success(err, cb) && (cb != null)) {
            return cb(null, rs.theValue());
          }
        });
      }
    });
  }

  interruptStatement(cb) {
    return this._interruptConnection((err, conn) => {
      if (this._success(err, cb)) {
        return conn.query(`SELECT statement_id FROM v_monitor.sessions WHERE session_id = '${this.sessionID}'`, (err, rs) => {
          var statementID;
          if (!this._success(err, cb)) {
            return conn.disconnect();
          } else if (rs.getLength() === 1 && (statementID = rs.theValue())) {
            return conn.query(`SELECT INTERRUPT_STATEMENT('${this.sessionID}', ${statementID})`, (err, rs) => {
              conn.disconnect();
              if (this._success(err, cb) && (cb != null)) {
                return cb(null, rs.theValue());
              }
            });
          } else {
            conn.disconnect();
            return this._success(`Session ${this.sessionID} is not running a statement at the moment.`, cb);
          }
        });
      }
    });
  }

};

// Exports
module.exports = Connection;
